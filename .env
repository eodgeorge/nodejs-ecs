DB_HOST=172.17.0.2    ##localhost
DB_PORT=5432
DB_USER=pgresql
DB_PASS=password
DB_NAME=eodsjtAurora
# AWS_ACCESS_KEY_ID=var.access-key
# AWS_SECRET_ACCESS_KEY=var.secret-key


# docker run -p 3000:3000 -e DB_HOST=172.17.0.2 eodgeorge/sjtnodejs:goosev1
# docker run  -e POSTGRES_USER=pgresql -e POSTGRES_PASSWORD=password -e POSTGRES_DB=eodsjtAurora -p 5432:5432 -d postgres
# docker exec -it ae0965897c99 bash
# docker exec -it ae0965897c99 psql -U pgresql -d eodsjtAurora
# docker exec -it 57ef61e6ba79 psql -U postgres -c "CREATE DATABASE eodsjtAurora;"
#localhost/127.0.0.1/containerIP/container name
#SELECT * FROM some_table;  -- Replace "some_table" with the actual table name
#\dt      switch database          \c postgres
# docker network connect my_network 0160e9b8e269  # Your app container
# docker network connect my_network dac894fbd2cf  # Your PostgreSQL container
# docker network create my_network
# docker run -d --name postgres --network my_network -e POSTGRES_USER=pgresql -e POSTGRES_PASSWORD=password -e POSTGRES_DB=eodsjtAurora postgres
# docker run -d --name postgres -e POSTGRES_USER=pgresql -e POSTGRES_PASSWORD=password -e POSTGRES_DB=eodsjtAurora postgres
# default bridge network will resolve/work as well
# INSERT INTO public.data (id, value) VALUES (2, 'Welcome Home');
# /var/lib/postgresql/data/postgresql.conf.sample or /var/lib/postgresql/data/postgresql.conf).
# /var/lib/postgresql/data/pg_hba.conf
# docker run (-v/--networt/-d/)
# configMap
# dockerfile
# npm cache clean --force
# npm install aws-sdk --legacy-peer-deps --force
# const AWS = require('aws-sdk');
# const cloudwatch = new AWS.CloudWatch({

# scrape_configs:
#   - job_name: 'postgres'
#     static_configs:
#       - targets: ['localhost:9187']  # Default port for postgres_exporter
# docker run --name postgres_exporter --net=host -e DATA_SOURCE_NAME="postgresql://postgres:yourpassword@localhost:5432/postgres?sslmode=disable" -d quay.io/prometheuscommunity/postgres-exporter
# docker run --name prometheus -v ./simple/custom-config.yaml:/etc/prometheus/custom-config.yml -d -p 9090:9090 prom/prometheus --config.file=/etc/prometheus/custom-config.yml
# psql -h localhost -U <your-db-username> -d <your-db-name>
# sudo systemctl start postgresql

# In AWS EC2 → Load Balancers, create an Application Load Balancer (ALB).
# Select Internal (not public) so it's only accessible within the VPC.
# Attach the ALB to your VPC & private subnets.
# Create Target Groups:
# backend-target-group → Register backend ECS tasks as targets.

# $ aws secretsmanager delete-secret --secret-id secret --force-delete-without-recovery


# resource "aws_rds_cluster" "aurora_postgresql" {
#   cluster_identifier   = "aurora-rds"
#   engine               = "aurora-postgresql"
#   engine_version       = "14.6"
#   database_name        = "eodsjtAurora"
#   master_username      = jsondecode(data.aws_secretsmanager_secret_version.version.secret_string)["DB_USER"]
#   master_password      = jsondecode(data.aws_secretsmanager_secret_version.version.secret_string)["DB_PASS"]
#   db_subnet_group_name = aws_db_subnet_group.aurora-postgresql.name
#   skip_final_snapshot  = true
# }


# resource "aws_rds_cluster_instance" "aurora_postgresql_instance" {
#   cluster_identifier  = aws_rds_cluster.aurora_postgresql.id
#   instance_class      = "db.t4g.medium"
#   engine              = "aurora-postgresql"
#   publicly_accessible = false
# }


# $ docker run -d amazonlinux sh -c "
# yum install -y yum-utils &&
# yum update -y &&
# yum install -y aws-cli &&
# tail -f /dev/null
# "

# docker cp path id:path
# docker cp fc0c160cb0d86c00ca54308e1fc32a916c05379c29690945246c0c9210569e1b:/fluent-bit/etc/fluent-bit.conf .

# $ aws elbv2 describe-target-groups --query "TargetGroups[*].[TargetGroupArn]" --output text

# $ aws elbv2 register-targets --target-group-arn arn:aws:elasticloadbalancing:eu-west-2:385771716406:targetgroup/target/2f98a47dd5b4be74 --targets Id=10.0.1.185

# If you have 4 running tasks, 
# setting deployment_minimum_healthy_percent = 50 
# ensures that at least 2 tasks remain operational during deployment.

# If you have 4 running tasks, 
# setting deployment_maximum_percent = 200 
# allows ECS to launch up to 8 tasks during deployment.

# Prevents downtime by ensuring at least some tasks remain available during updates.
# Allows blue-green deployments by running new tasks alongside the old ones before switching.
# Avoids traffic disruption if running behind an ALB or NLB.

data "aws_ecs_task" "example" {
  cluster = aws_ecs_cluster.ecs.id
  task    = "arn:aws:ecs:eu-west-2:385771716406:task/ecs/e19cd34f825a42b587ee1901cdd99f32"
}

resource "aws_lb_target_group_attachment" "ecs-target-attach" {
  target_group_arn = aws_lb_target_group.target.arn
  target_id        = data.aws_ecs_task.example.containers[0].network_interfaces[0].private_ipv4_address
}